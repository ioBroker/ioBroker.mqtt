{"version":3,"file":"securityChecker.js","sourceRoot":"","sources":["../../src/lib/securityChecker.ts"],"names":[],"mappings":"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","sourcesContent":["import https from 'node:https';\nimport { connect, type MqttClient, type IClientOptions } from 'mqtt';\n\nfunction _getPublicIP(): Promise<string> {\n    return new Promise((resolve, reject) => {\n        https\n            .get('https://ip.iobroker.in', res => {\n                const data: Uint8Array[] = [];\n\n                res.on('data', chunk => data.push(chunk));\n\n                res.on('end', () => resolve(Buffer.concat(data).toString()));\n            })\n            .on('error', err => reject(new Error(err.message)));\n    });\n}\n\nfunction _checkMqttServer(url: string): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n        const opts: IClientOptions = {\n            clientId: 'ioBrokerChecker',\n            keepalive: 1 /* in seconds */,\n            protocolId: 'MQTT',\n            protocolVersion: 4,\n            reconnectPeriod: 30 * 1000 /* in milliseconds */,\n            connectTimeout: 2 * 1000 /* in milliseconds */,\n            clean: true,\n            rejectUnauthorized: false /* added option to disable certification validation */,\n        };\n\n        let client: MqttClient | null = connect(url, opts);\n        client.on('connect', () => {\n            if (client) {\n                try {\n                    client.end();\n                } catch {\n                    // ignore error\n                }\n                client = null;\n                reject(new Error(`Your MQTT server is reachable from internet without protection under \"${url}\"`));\n            }\n        });\n        client.on('error', () => {\n            if (client) {\n                try {\n                    client.end();\n                } catch {\n                    // ignore error\n                }\n                client = null;\n                resolve();\n            }\n        });\n\n        client.on('close', () => {\n            if (client) {\n                client = null;\n                resolve();\n            }\n        });\n    });\n}\n\n/**\n * Checks public IP address of the server and tries to connect to it.\n * Throws error if connection is possible.\n */\nexport async function checkPublicIP(port: number | string, secure?: boolean): Promise<void> {\n    if (typeof port === 'string') {\n        port = parseInt(port, 10);\n    }\n    let publicIP;\n    // we check the public ip address of the server\n    try {\n        publicIP = await _getPublicIP();\n    } catch {\n        // Ignore. We just don't know the public IP\n    }\n\n    if (publicIP) {\n        // check http://publicIP:port\n        await _checkMqttServer(`${secure ? 'mqtts' : 'mqtt'}://${publicIP}${port ? `:${port}` : ''}`);\n\n        // check http://publicIP:80\n        if (!secure && port !== 1883) {\n            await _checkMqttServer(`mqtt://${publicIP}:1883`);\n        }\n        if (port !== 8883) {\n            await _checkMqttServer(`mqtts://${publicIP}:8883`);\n        }\n    }\n}\n"]}